.data
msg_div_zero: .asciiz "Illegal Division By Zero"
msg_null_ptr: .asciiz "Invalid Pointer Dereference"
msg_bounds: .asciiz "Access Violation"
grades_15: .word 0
moish_11: .word 0
COMPILATION_12: .word 0
TAU_13: .word 0
i_18: .word 0
sum_19: .word 0
age_9: .word 0

.text
.globl main

main:
    j __user_main    # Jump to main function
Person_getAge:
    # Function prologue
    addi $sp, $sp, -8    # allocate stack frame
    sw $ra, 4($sp)    # save return address
    sw $fp, 0($sp)    # save frame pointer
    addi $fp, $sp, 8    # set new frame pointer

    # Temp_0 := age_9
    lw $t0, age_9

    # RETURN Temp_0
    move $v0, $t0    # return value
    # Function epilogue
    lw $ra, 4($sp)    # restore return address
    lw $fp, 0($sp)    # restore frame pointer
    addi $sp, $sp, 8    # deallocate stack frame
    jr $ra

    # Implicit return for void function
    # Function epilogue
    lw $ra, 4($sp)    # restore return address
    lw $fp, 0($sp)    # restore frame pointer
    addi $sp, $sp, 8    # deallocate stack frame
    jr $ra

Person_birthday:
    # Function prologue
    addi $sp, $sp, -8    # allocate stack frame
    sw $ra, 4($sp)    # save return address
    sw $fp, 0($sp)    # save frame pointer
    addi $fp, $sp, 8    # set new frame pointer

    # Temp_2 := age_9
    lw $t1, age_9

    # Temp_3 := 1
    li $t0, 1

    # Temp_1 := Temp_2 + Temp_3
    # Saturated addition
    add $t0, $t1, $t0
    li $t9, 32767
    bgt $t0, $t9, saturate_add_max_0
    li $t9, -32768
    blt $t0, $t9, saturate_add_min_1
    j saturate_add_done_2
saturate_add_max_0:
    li $t0, 32767
    j saturate_add_done_2
saturate_add_min_1:
    li $t0, -32768
saturate_add_done_2:

    # age_9 := Temp_1
    sw $t0, age_9

    # Implicit return for void function
    # Function epilogue
    lw $ra, 4($sp)    # restore return address
    lw $fp, 0($sp)    # restore frame pointer
    addi $sp, $sp, 8    # deallocate stack frame
    jr $ra

Student_getAverage:
    # Function prologue
    addi $sp, $sp, -8    # allocate stack frame
    sw $ra, 4($sp)    # save return address
    sw $fp, 0($sp)    # save frame pointer
    addi $fp, $sp, 8    # set new frame pointer

    # Allocate i_18
    # Allocate i_18

    # Temp_4 := 0
    li $t0, 0

    # i_18 := Temp_4
    sw $t0, i_18

    # Allocate sum_19
    # Allocate sum_19

    # Temp_5 := 0
    li $t0, 0

    # sum_19 := Temp_5
    sw $t0, sum_19

Label_1_start:

    # Temp_7 := i_18
    lw $t1, i_18

    # Temp_8 := 10
    li $t0, 10

    # Temp_6 := Temp_7 < Temp_8
    slt $t0, $t1, $t0

    # JumpIfEqToZero Temp_6 Label_0_end
    beq $t0, $zero, Label_0_end

    # Temp_10 := sum_19
    lw $t0, sum_19

    # Temp_11 := grades_15
    lw $t1, grades_15

    # Temp_12 := i_18
    lw $t2, i_18

    # Temp_13 := ARRAY_ACCESS(Temp_11[Temp_12], elemSize=4)
    # Check array bounds
    beq $t1, $zero, error_null_pointer
    bltz $t2, error_bounds
    lw $s0, 0($t1)    # load array length
    bge $t2, $s0, error_bounds
    sll $s0, $t2, 2    # index * 4
    addi $s0, $s0, 4    # + 4 (skip length)
    add $s0, $t1, $s0
    lw $t1, 0($s0)

    # Temp_9 := Temp_10 + Temp_13
    # Saturated addition
    add $t0, $t0, $t1
    li $t9, 32767
    bgt $t0, $t9, saturate_add_max_3
    li $t9, -32768
    blt $t0, $t9, saturate_add_min_4
    j saturate_add_done_5
saturate_add_max_3:
    li $t0, 32767
    j saturate_add_done_5
saturate_add_min_4:
    li $t0, -32768
saturate_add_done_5:

    # sum_19 := Temp_9
    sw $t0, sum_19

    # Temp_15 := i_18
    lw $t0, i_18

    # Temp_16 := 1
    li $t1, 1

    # Temp_14 := Temp_15 + Temp_16
    # Saturated addition
    add $t0, $t0, $t1
    li $t9, 32767
    bgt $t0, $t9, saturate_add_max_6
    li $t9, -32768
    blt $t0, $t9, saturate_add_min_7
    j saturate_add_done_8
saturate_add_max_6:
    li $t0, 32767
    j saturate_add_done_8
saturate_add_min_7:
    li $t0, -32768
saturate_add_done_8:

    # i_18 := Temp_14
    sw $t0, i_18

    # Jump Label_1_start
    j Label_1_start

Label_0_end:

    # Temp_18 := sum_19
    lw $t0, sum_19

    # Temp_19 := 10
    li $t1, 10

    # Temp_17 := Temp_18 / Temp_19
    # Check division by zero
    beq $t1, $zero, error_div_by_zero
    # Saturated division
    div $t0, $t0, $t1
    li $t9, 32767
    bgt $t0, $t9, saturate_div_max_9
    li $t9, -32768
    blt $t0, $t9, saturate_div_min_10
    j saturate_div_done_11
saturate_div_max_9:
    li $t0, 32767
    j saturate_div_done_11
saturate_div_min_10:
    li $t0, -32768
saturate_div_done_11:

    # RETURN Temp_17
    move $v0, $t0    # return value
    # Function epilogue
    lw $ra, 4($sp)    # restore return address
    lw $fp, 0($sp)    # restore frame pointer
    addi $sp, $sp, 8    # deallocate stack frame
    jr $ra

    # Implicit return for void function
    # Function epilogue
    lw $ra, 4($sp)    # restore return address
    lw $fp, 0($sp)    # restore frame pointer
    addi $sp, $sp, 8    # deallocate stack frame
    jr $ra

__user_main:
    # Function prologue
    addi $sp, $sp, -8    # allocate stack frame
    sw $ra, 4($sp)    # save return address
    sw $fp, 0($sp)    # save frame pointer
    addi $fp, $sp, 8    # set new frame pointer

    # Allocate moish_11
    # Allocate moish_11

    # Temp_20 := NEW_OBJECT("Student", size=28)
    # Allocate object: Student
    li $a0, 28
    li $v0, 9    # malloc
    syscall
    move $t0, $v0
    sw $zero, 0($v0)
    sw $zero, 4($v0)
    sw $zero, 8($v0)
    sw $zero, 12($v0)
    sw $zero, 16($v0)
    sw $zero, 20($v0)
    sw $zero, 24($v0)

    # moish_11 := Temp_20
    sw $t0, moish_11

    # Temp_22 := 10
    li $t0, 10

    # Temp_21 := NEW_ARRAY(int[Temp_22], elemSize=4)
    # Allocate array
    li $s0, 4
    mul $s0, $t0, $s0    # size * elemSize
    addi $a0, $s0, 4    # +4 for length field
    li $v0, 9    # malloc
    syscall
    sw $t0, 0($v0)    # store length
    move $t0, $v0

    # Temp_23 := moish_11
    lw $t0, moish_11

    # Temp_25 := 12
    li $t0, 12

    # Temp_24 := NEW_ARRAY(int[Temp_25], elemSize=4)
    # Allocate array
    li $s0, 4
    mul $s0, $t0, $s0    # size * elemSize
    addi $a0, $s0, 4    # +4 for length field
    li $v0, 9    # malloc
    syscall
    sw $t0, 0($v0)    # store length
    move $t0, $v0

    # Temp_26 := moish_11
    lw $t0, moish_11

    # Allocate COMPILATION_12
    # Allocate COMPILATION_12

    # Temp_27 := 6
    li $t0, 6

    # COMPILATION_12 := Temp_27
    sw $t0, COMPILATION_12

    # Temp_28 := 99
    li $t1, 99

    # Temp_29 := moish_11
    lw $t0, moish_11

    # Temp_30 := FIELD_ACCESS(Temp_29.grades, offset=12)
    # Check null pointer
    beq $t0, $zero, error_null_pointer
    lw $t0, 12($t0)

    # Temp_31 := COMPILATION_12
    lw $t2, COMPILATION_12

    # ARRAY_STORE(Temp_30[Temp_31], Temp_28, elemSize=4)
    # Check array bounds
    beq $t0, $zero, error_null_pointer
    bltz $t2, error_bounds
    lw $s0, 0($t0)    # load array length
    bge $t2, $s0, error_bounds
    sll $s0, $t2, 2
    addi $s0, $s0, 4
    add $s0, $t0, $s0
    sw $t1, 0($s0)

    # Allocate TAU_13
    # Allocate TAU_13

    # Temp_33 := 37
    li $t0, 37

    # Temp_32 := NEW_ARRAY(int[Temp_33], elemSize=4)
    # Allocate array
    li $s0, 4
    mul $s0, $t0, $s0    # size * elemSize
    addi $a0, $s0, 4    # +4 for length field
    li $v0, 9    # malloc
    syscall
    sw $t0, 0($v0)    # store length
    move $t0, $v0

    # TAU_13 := Temp_32
    sw $t0, TAU_13

    # Temp_34 := moish_11
    lw $t1, moish_11

    # Temp_35 := TAU_13
    lw $t2, TAU_13

    # Temp_36 := 3
    li $t0, 3

    # ARRAY_STORE(Temp_35[Temp_36], Temp_34, elemSize=4)
    # Check array bounds
    beq $t2, $zero, error_null_pointer
    bltz $t0, error_bounds
    lw $s0, 0($t2)    # load array length
    bge $t0, $s0, error_bounds
    sll $s0, $t0, 2
    addi $s0, $s0, 4
    add $s0, $t2, $s0
    sw $t1, 0($s0)

    # Temp_37 := 999
    li $t2, 999

    # Temp_38 := TAU_13
    lw $t1, TAU_13

    # Temp_39 := 3
    li $t0, 3

    # Temp_40 := ARRAY_ACCESS(Temp_38[Temp_39], elemSize=4)
    # Check array bounds
    beq $t1, $zero, error_null_pointer
    bltz $t0, error_bounds
    lw $s0, 0($t1)    # load array length
    bge $t0, $s0, error_bounds
    sll $s0, $t0, 2    # index * 4
    addi $s0, $s0, 4    # + 4 (skip length)
    add $s0, $t1, $s0
    lw $t0, 0($s0)

    # Temp_41 := FIELD_ACCESS(Temp_40.lastYearSalaries, offset=8)
    # Check null pointer
    beq $t0, $zero, error_null_pointer
    lw $t3, 8($t0)

    # Temp_42 := TAU_13
    lw $t1, TAU_13

    # Temp_43 := 3
    li $t0, 3

    # Temp_44 := ARRAY_ACCESS(Temp_42[Temp_43], elemSize=4)
    # Check array bounds
    beq $t1, $zero, error_null_pointer
    bltz $t0, error_bounds
    lw $s0, 0($t1)    # load array length
    bge $t0, $s0, error_bounds
    sll $s0, $t0, 2    # index * 4
    addi $s0, $s0, 4    # + 4 (skip length)
    add $s0, $t1, $s0
    lw $t0, 0($s0)

    # Temp_45 := FIELD_ACCESS(Temp_44.grades, offset=12)
    # Check null pointer
    beq $t0, $zero, error_null_pointer
    lw $t0, 12($t0)

    # Temp_46 := COMPILATION_12
    lw $t1, COMPILATION_12

    # Temp_47 := ARRAY_ACCESS(Temp_45[Temp_46], elemSize=4)
    # Check array bounds
    beq $t0, $zero, error_null_pointer
    bltz $t1, error_bounds
    lw $s0, 0($t0)    # load array length
    bge $t1, $s0, error_bounds
    sll $s0, $t1, 2    # index * 4
    addi $s0, $s0, 4    # + 4 (skip length)
    add $s0, $t0, $s0
    lw $t0, 0($s0)

    # ARRAY_STORE(Temp_41[Temp_47], Temp_37, elemSize=4)
    # Check array bounds
    beq $t3, $zero, error_null_pointer
    bltz $t0, error_bounds
    lw $s0, 0($t3)    # load array length
    bge $t0, $s0, error_bounds
    sll $s0, $t0, 2
    addi $s0, $s0, 4
    add $s0, $t3, $s0
    sw $t2, 0($s0)

    # Exit program
    li $v0, 10
    syscall

error_div_by_zero:
    la $a0, msg_div_zero
    li $v0, 4
    syscall
    li $v0, 10
    syscall

error_null_pointer:
    la $a0, msg_null_ptr
    li $v0, 4
    syscall
    li $v0, 10
    syscall

error_bounds:
    la $a0, msg_bounds
    li $v0, 4
    syscall
    li $v0, 10
    syscall

PrintInt:
    # Print integer (expects value in p_10 variable)
    lw $a0, p_10    # load value to print
    li $v0, 1    # syscall: print_int
    syscall
    li $a0, 32    # print space
    li $v0, 11    # syscall: print_char
    syscall
    jr $ra    # return

PrintString:
    # Print string (expects value in p_10 variable)
    lw $a0, p_10    # load string address to print
    li $v0, 4    # syscall: print_string
    syscall
    jr $ra    # return

# Program exit
    li $v0, 10
    syscall
